//
// Created by Pretorius, Christiaan on 2022-10-01.
//

#ifndef NNNN_SPARSITY_H
#define NNNN_SPARSITY_H
#include <basics.h>
#include <vector>
namespace noodle {
    using namespace std;
    using namespace Eigen;

    struct block_sparsity{
        enum {
            block_size = 16
        };

        struct block_entry {
            index_t row;
            index_t col;
            index_t size = block_size;
            block_entry(index_t row, index_t col) : row(row), col(col) {}
            block_entry(index_t row, index_t col, index_t size) : row(row), col(col), size(size)  {}
        };
        // the minimum actual sparsity required for block sparsity backprop optimizations to take place
        num_t opt_sparseness_threshold = 0.6;
        mutable mat_t tweights = NULL_M();
        index_t calc_count = 0;
        std::vector<block_entry> zero_blocks;
        std::vector<block_entry> valued_blocks;
        num_t sparseness = 0;
        num_t actual_sparseness = 0;
        num_t get_sparseness(const mat_t &w) const {
            return (num_t) (w.array() == 0).count() / (num_t) w.size();
        }
        num_t get_block_sparseness(const mat_t& weights) const {
            num_t zeroes = zero_blocks.size() * block_size;

            return zeroes/(num_t)weights.size();
        }
        void zero_weights(mat_t &weights) {
            for (auto zb: zero_blocks) {
                weights.block<1, block_size>(zb.row, zb.col).array() = 0;
            }
        }
        void create_value_mask(const mat_t& weights){
            valued_blocks.clear();
            index_t cols = weights.cols();
            for (index_t r = 0; r < weights.rows(); ++r) {
                for (index_t b = 0; b < cols; b += block_size) {
                    if (b + block_size < cols) {
                        auto block = weights.block<1, block_size>(r, b);
                        if((block.array() == 0).count() < block_size){
                            valued_blocks.push_back({r, b});
                        }
                    }else{
                        index_t diff = b + block_size - cols;
                        assert(diff <= block_size);
                        valued_blocks.push_back({r, b, block_size - diff});
                    }
                }
            }
        }
        void create_block_mask(const mat_t& weights){
            zero_blocks.clear();
            valued_blocks.clear();
            index_t cols = weights.cols();
            for (index_t r = 0; r < weights.rows(); ++r) {
                for (index_t b = 0; b < cols; b += block_size) {
                    if (b + block_size < cols) {
                        auto block = weights.block<1, block_size>(r, b);
                        if((block.array() == 0).count() == block_size){
                            zero_blocks.push_back({r, b});
                        }else{
                            valued_blocks.push_back({r, b});
                        }
                    }else{
                        index_t diff = b + block_size - cols;
                        assert(diff <= block_size);
                        valued_blocks.push_back({r, b, block_size - diff});
                    }
                }
            }
            actual_sparseness = get_block_sparseness(weights);
        }
        __attribute__((noinline))
        void reduce_weights(mat_t &weights) {
            zero_weights(weights);
            num_t prev_sparsity = get_block_sparseness(weights);
            if(prev_sparsity >= sparseness){
                return;
            }
            //cout << "prev_sparsity " << prev_sparsity << endl;
            if(valued_blocks.empty())
                create_value_mask(weights);

            num_t abs_mean = weights.array().abs().mean();
            num_t abs_max = weights.array().abs().maxCoeff();
            num_t low_water = 0.2;
            num_t high_water = abs_mean;
            num_t zeroed = 0;
            num_t values = weights.size();

            // TODO: shrink_factor should be related to the abs diff between min and max weight
            const num_t shrink_factor = 0.75;
            const num_t expand_factor = 1.1;
            for (index_t z = 0; z < 4; z++) {
                zeroed = 0;
                for(auto bl : valued_blocks){
                    if (bl.size != block_size) {
                        continue;
                    }
                    auto block = weights.block<1, block_size>(bl.row, bl.col);
                    num_t b_avg = block.array().abs().mean();
                    if (b_avg < high_water) {
                        block.array() *= shrink_factor;
                        b_avg *= shrink_factor;
                    };
                    if (b_avg < low_water) {
                        block.array() = 0;
                        zeroed++;
                        num_t current_sparseness = ((num_t)zeroed+ zero_blocks.size())*block_size / values;
                        if (zeroed > 40 || current_sparseness > sparseness) {
                            create_block_mask(weights);
                            return;
                        }
                    }
                }
                high_water *= expand_factor;
                if(high_water > abs_max){
                    break;
                }
            } // for
            create_block_mask(weights);

#if 0
            weights = weights.unaryExpr([&](num_t x) -> num_t{
                num_t x1 = abs(x) < highwater ? x*0.9999 : x;
                return abs(x1 ) < lowwater ? 0 : x1;
            });
#endif
        }
        /**
         * sparse optimised projection function for bp
         * @param o destination matrix
         * @param l origin vector A
         * @param r origin vector B
         */
        __attribute__((noinline))
        void project_mul(mat_t &o, const vec_t &l, const vec_t &r, num_t to_mul = 0) const {
            if(!valued_blocks.empty() && actual_sparseness > opt_sparseness_threshold){
                if(o.size()==0){
                    o = mat_t::Zero(l.rows(), r.rows());
                }
                for (auto e: valued_blocks) {
                    for(index_t c = 0; c < e.size; ++c){
                        o(e.row, e.col + c) = l(e.row) * r(e.col + c) * to_mul;
                    }
                }
            } else {
                o = l * r.transpose();
                o *= to_mul;
            }
        }
        __attribute__((noinline))
        void _base_project_mul_add(mat_t &o, const vec_t &l, const vec_t &r, num_t to_mul = 0) const {
            mat_t t = l * r.transpose();
            t *= to_mul;
            o += t;
        }
        __attribute__((noinline))
        void project_mul_add(mat_t &o, const vec_t &l, const vec_t &r, num_t to_mul = 0) const {
            if(o.size()==0){
                o = mat_t::Zero(l.rows(), r.rows());
            }
            if(!valued_blocks.empty() && actual_sparseness > 0.3){

                for (auto e: valued_blocks) {
                    for(index_t c = 0; c < e.size; ++c){
                        o(e.row, e.col + c) += l(e.row) * r(e.col + c) * to_mul;
                    }
                }
            } else {
                _base_project_mul_add(o, l, r, to_mul);
            }
        }

        __attribute__((noinline))
        void _base_vec_mul_assign(vec_t& o, const mat_t& l, const vec_t &r){
            o = l * r;
        }

        __attribute__((noinline))
        void vec_mul_assign(vec_t& o, const mat_t& l, const vec_t &r){
            if(!valued_blocks.empty() && actual_sparseness > opt_sparseness_threshold){
                o.resize(l.rows(),1);
                o.setZero(); /// because its assign not update

                for (auto e: valued_blocks) {
                    num_t dot =0;
                    if(e.size==block_size){
                        dot = l.block<1, block_size>(e.row,e.col).row(0) *
                        r.block<block_size,1>(e.col,0).col(0);
                    }else{
                        dot = l.block(e.row,e.col, 1, e.size).row(0) *
                        r.block(e.col,0,e.size,1).col(0);
                    }

                    o(e.row,0) += dot;
                }
#if 0
                cout << "========================" << endl;
                cout << "o.rows() " << o.rows() << ", o.cols() " << o.cols() << endl;
                cout << o << endl;
                cout << "========================" << endl;

                vec_t v = NULL_V();
                _base_vec_mul_assign(v, l, r);
                cout << "v.rows() " << v.rows() << ", v.cols() " << v.cols() << endl;
                cout << v << endl;
                cout << "========================" << endl;
                int i;
                cin >> i;

#endif
            }else{
                _base_vec_mul_assign(o, l, r);
            }
        }

        /**
         * sparse optimized value masked matrix transpose multiply
         * only multiplies blocks
         * @param result
         * @param weights
         * @param error
         */
        void mask_mul(vec_t& result, const mat_t& weights, const vec_t& error) const {
            // if weights == 50x100
            //  100x1 = 100x50 * 50x1
            // result = weights.transpose() * error
            if(!valued_blocks.empty() && actual_sparseness > 0.99){
                result = vec_t::Zero(weights.cols(), 1);
                tweights = mat_t::Zero(1, block_size);
                index_t cells = 0;
                for (auto e: valued_blocks) {
                    cells += e.size;
                    num_t mr = error(e.row, 0);
                    for(index_t c = 0; c < e.size; ++c){
                        tweights(0, c) = weights(e.row, e.col+c);
                    }
                    tweights *= mr;
                    for(index_t c = 0; c < e.size; ++c){
                        result(e.col + c, 0) += tweights(0, c);
                    }
                }
#if 0
                index_t zero_actual = 0;
                for (auto z: zero_blocks) {
                    auto block = weights.block<1, block_size>(z.row, z.col);
                    if((block.array()==0).count() == block_size){
                        ++zero_actual;
                    }
                }
                vec_t test = weights.transpose() * error;
                if(test != result){
                    cout << "zero_actual " << zero_actual << ", " << zero_blocks.size() << endl;
                    cout << weights.size() << "," << (cells + (zero_blocks.size() * block_size)) << endl;
                    cout << test.rows() << ", " << test.cols() << endl;
                    cout << result.rows() << ", " << result.cols() << endl;
                    cout << test << endl;
                    cout << "------" << endl;
                    cout <<  result << endl;
                    int t;
                    cin >> t;
                }
#endif
            } else {
                result = weights.transpose() * error;
            }
        }
    };
}
#endif //NNNN_SPARSITY_H
